<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Helvetica Neue', sans-serif; }
        canvas { display: block; }
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            color: #d4af37; /* é‡‘å±é‡‘ */
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }
        
        /* é¡¶éƒ¨æ§åˆ¶æ  */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
        }
        
        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            background: linear-gradient(to right, #d4af37, #fcf6ba, #d4af37);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .upload-btn {
            background: rgba(47, 90, 47, 0.8);
            border: 1px solid #d4af37;
            color: #fff;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .upload-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 15px #d4af37; }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-panel {
            text-align: right;
        }
        .state-indicator {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ff4d4d;
        }
        .gesture-hint {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* åº•éƒ¨åŠ è½½ä¸è§†é¢‘é¢„è§ˆ */
        .bottom-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        #loading {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #d4af37;
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border: 1px solid #d4af37;
            z-index: 100;
        }

        /* éšè—åŸå§‹è§†é¢‘ï¼Œæˆ‘ä»¬åªç”¨æ•°æ® */
        .input_video { display: none; }
        
        /* æ‘„åƒå¤´é¢„è§ˆå°çª— */
        .camera-preview {
            width: 160px;
            height: 120px;
            background: #000;
            border: 1px solid #d4af37;
            border-radius: 8px;
            overflow: hidden;
            opacity: 0.7;
            position: relative;
        }
        .camera-preview video {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);
        }

        #instructions {
            max-width: 300px;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-left: 2px solid #d4af37;
            font-size: 0.9rem;
            line-height: 1.5;
        }
    </style>
    
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“...</div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="top-bar">
            <div>
                <h1>MERRY CHRISTMAS 3D</h1>
                <div style="font-size: 0.8rem; color: #aaa;">GESTURE CONTROLLED EXPERIENCE</div>
            </div>
            <div class="status-panel">
                <div class="state-indicator" id="current-state">STATE: TREE</div>
                <div class="gesture-hint" id="gesture-hint">ç­‰å¾…æ‰‹åŠ¿...</div>
            </div>
        </div>

        <div class="bottom-bar">
            <div id="instructions">
                <p>ğŸ– <b>å¼ å¼€äº”æŒ‡:</b> æ•£å¼€æˆç…§ç‰‡äº‘</p>
                <p>âœŠ <b>æ¡ç´§æ‹³å¤´:</b> èšåˆä¸ºåœ£è¯æ ‘</p>
                <p>ğŸ‘Œ <b>åŒæŒ‡æåˆ:</b> æŠ“å–/æŸ¥çœ‹ç…§ç‰‡</p>
                <p>ğŸ‘‹ <b>æ‰‹æŒç§»åŠ¨:</b> æ—‹è½¬è§†è§’ (æ•£å¼€æ¨¡å¼)</p>
                <label class="upload-btn">
                    ä¸Šä¼ ç…§ç‰‡
                    <input type="file" id="photo-input" multiple accept="image/*" style="display: none;">
                </label>
            </div>
            <div class="camera-preview">
                <video class="input_video"></video>
            </div>
        </div>
    </div>

    <!-- Three.js Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            colors: {
                green: 0x2F5A2F,
                gold: 0xFFD700,
                red: 0xB22222,
                white: 0xFFFFFF
            },
            count: 250, // æ€»å…ƒç´ æ•°é‡
            treeHeight: 25,
            treeRadius: 10,
            cloudRadius: 30,
            photoRatio: 0.25 // 25% çš„å…ƒç´ æ˜¯ç…§ç‰‡
        };

        const STATE = {
            TREE: 'TREE',
            CLOUD: 'CLOUD',
            INSPECT: 'INSPECT'
        };

        let currentState = STATE.TREE;
        let targetRotation = { x: 0, y: 0 };
        let activePhotoIndex = -1; // å½“å‰æ­£åœ¨æŸ¥çœ‹çš„ç…§ç‰‡ç´¢å¼•

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.02); // è¿·é›¾å¢åŠ æ·±åº¦æ„Ÿ

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // ç”µå½±æ„Ÿè‰²è°ƒæ˜ å°„
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // --- ç¯å…‰ç³»ç»Ÿ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffeeb1, 500);
        spotLight.position.set(20, 50, 20);
        spotLight.angle = Math.PI / 4;
        spotLight.penumbra = 0.5;
        scene.add(spotLight);

        const pointLight = new THREE.PointLight(0xB22222, 100, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // --- åæœŸå¤„ç† (è¾‰å…‰) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- æè´¨ä¸å‡ ä½•ä½“ ---
        const materials = {
            gold: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                metalness: 1.0, 
                roughness: 0.2,
                emissive: 0xaa6600,
                emissiveIntensity: 0.2
            }),
            red: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, 
                metalness: 0.3, 
                roughness: 0.4,
                emissive: 0x550000,
                emissiveIntensity: 0.2
            }),
            green: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, 
                metalness: 0.0, 
                roughness: 0.8 
            }),
            photo: new THREE.MeshBasicMaterial({ color: 0xffffff }) // åŸºç¡€ç…§ç‰‡æè´¨å ä½
        };

        const geometries = {
            sphere: new THREE.SphereGeometry(0.6, 16, 16),
            box: new THREE.BoxGeometry(0.8, 0.8, 0.8),
            plane: new THREE.PlaneGeometry(3, 4) // ç…§ç‰‡æ¯”ä¾‹ 3:4
        };

        // --- ç”Ÿæˆé»˜è®¤ç…§ç‰‡çº¹ç† (Canvas) ---
        function createPlaceholderTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 340;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, 256, 340);
            ctx.fillStyle = '#1a1a1a';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("PHOTO", 128, 150);
            ctx.fillText(text, 128, 190);
            
            // åŠ ç‚¹è£…é¥°è¾¹æ¡†
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = 10;
            ctx.strokeRect(5, 5, 246, 330);

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        let userPhotos = []; // å­˜å‚¨ç”¨æˆ·ä¸Šä¼ çš„çº¹ç†
        
        // --- æ ¸å¿ƒå¯¹è±¡ç®¡ç† ---
        const objects = []; // { mesh, treePos, cloudPos, type }
        const group = new THREE.Group();
        scene.add(group);

        // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆåœ†é”¥ä½“ä¸Šçš„ç‚¹
        function getTreePosition(i, total) {
            const ratio = i / total;
            const y = (1 - ratio) * CONFIG.treeHeight - CONFIG.treeHeight / 2;
            const radius = ratio * CONFIG.treeRadius;
            const angle = i * 0.5; // èºæ—‹è§’åº¦
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            return new THREE.Vector3(x, y, z);
        }

        // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆçƒä½“å†…çš„éšæœºç‚¹
        function getCloudPosition() {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(Math.random()) * CONFIG.cloudRadius; // å‡åŒ€åˆ†å¸ƒåœ¨çƒä½“å†…
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        // åˆå§‹åŒ–å¯¹è±¡
        function initObjects() {
            for (let i = 0; i < CONFIG.count; i++) {
                let mesh;
                let type;
                
                // å†³å®šç±»å‹ï¼šç…§ç‰‡ vs è£…é¥°å“
                if (Math.random() < CONFIG.photoRatio) {
                    type = 'photo';
                    const mat = new THREE.MeshBasicMaterial({ 
                        map: userPhotos.length > 0 ? userPhotos[i % userPhotos.length] : createPlaceholderTexture(`#${i}`),
                        side: THREE.DoubleSide
                    });
                    mesh = new THREE.Mesh(geometries.plane, mat);
                    mesh.scale.set(0.5, 0.5, 0.5); // åˆå§‹å°ä¸€ç‚¹
                } else {
                    type = 'ornament';
                    const rand = Math.random();
                    let mat = rand > 0.6 ? materials.gold : (rand > 0.3 ? materials.red : materials.green);
                    let geo = Math.random() > 0.5 ? geometries.sphere : geometries.box;
                    mesh = new THREE.Mesh(geo, mat);
                }

                const treePos = getTreePosition(i, CONFIG.count);
                const cloudPos = getCloudPosition();

                // åˆå§‹ä½ç½®è®¾ä¸ºæ•£å¼€ï¼ˆç¨å¾®æœ‰ç‚¹åŠ¨ç”»æ•ˆæœï¼‰
                mesh.position.copy(cloudPos);
                
                // éšæœºæ—‹è½¬
                mesh.rotation.x = Math.random() * Math.PI;
                mesh.rotation.y = Math.random() * Math.PI;

                group.add(mesh);
                objects.push({
                    mesh,
                    treePos,
                    cloudPos,
                    type,
                    velocity: new THREE.Vector3(0,0,0) // ç”¨äºç‰©ç†æ¨¡æ‹Ÿæ„Ÿè§‰
                });
            }
        }

        initObjects();

        // --- ç…§ç‰‡ä¸Šä¼ é€»è¾‘ ---
        const fileInput = document.getElementById('photo-input');
        fileInput.addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                userPhotos = []; // æ¸…ç©ºæ—§çš„
                let loadedCount = 0;
                
                Array.from(files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image();
                        img.onload = () => {
                            const tex = new THREE.Texture(img);
                            tex.colorSpace = THREE.SRGBColorSpace;
                            tex.needsUpdate = true;
                            userPhotos.push(tex);
                            loadedCount++;
                            
                            // å½“æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆ–éƒ¨åˆ†åŠ è½½å®Œï¼Œæ›´æ–°ç°æœ‰çš„ç…§ç‰‡Mesh
                            if (loadedCount === files.length) {
                                updatePhotoTextures();
                            }
                        };
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            }
        });

        function updatePhotoTextures() {
            let photoIndex = 0;
            objects.forEach(obj => {
                if (obj.type === 'photo') {
                    obj.mesh.material.map = userPhotos[photoIndex % userPhotos.length];
                    obj.mesh.material.needsUpdate = true;
                    photoIndex++;
                }
            });
        }

        // --- åŠ¨ç”»ä¸æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. å¹³æ»‘å¤„ç†ç»„çš„æ—‹è½¬ (æ‰‹åŠ¿æ§åˆ¶)
            group.rotation.y += (targetRotation.x - group.rotation.y) * 0.05;
            group.rotation.x += (targetRotation.y - group.rotation.x) * 0.05;
            
            // è‡ªåŠ¨å¾®æ—‹è½¬å¢åŠ åŠ¨æ„Ÿ
            if(currentState === STATE.TREE) {
                group.rotation.y += 0.002;
            }

            // 2. æ›´æ–°æ¯ä¸ªç‰©ä½“çš„ä½ç½®
            objects.forEach((obj, idx) => {
                let target;
                let scaleTarget = 1;
                
                if (currentState === STATE.TREE) {
                    target = obj.treePos;
                    if (obj.type === 'photo') scaleTarget = 0.5;
                    else scaleTarget = 1;
                    
                    // æ ‘çŠ¶æ€ä¸‹ï¼Œç‰©ä½“æœå‘å¤–
                    obj.mesh.lookAt(0, obj.treePos.y, 0);

                } else if (currentState === STATE.CLOUD) {
                    target = obj.cloudPos;
                    // äº‘çŠ¶æ€ä¸‹è½»å¾®æµ®åŠ¨
                    const floatY = Math.sin(time + idx) * 0.5;
                    target = target.clone().add(new THREE.Vector3(0, floatY, 0));
                    
                    if (obj.type === 'photo') {
                        scaleTarget = 1;
                        obj.mesh.lookAt(camera.position); // ç…§ç‰‡å§‹ç»ˆæœå‘ç›¸æœº
                    } else {
                        obj.mesh.rotation.x += 0.01;
                        obj.mesh.rotation.y += 0.01;
                    }

                } else if (currentState === STATE.INSPECT) {
                    // æ£€æŸ¥æ¨¡å¼
                    if (idx === activePhotoIndex) {
                        // é€‰ä¸­çš„ç…§ç‰‡é£åˆ°é•œå¤´å‰
                        // éœ€è¦è½¬æ¢ä¸–ç•Œåæ ‡ç³»ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼šç›´æ¥è¦†ç›–ä½ç½®é€»è¾‘
                        // ä¸ºäº†ä¸å— Group æ—‹è½¬å½±å“ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦åå‘è®¡ç®—æˆ–è€…æŠŠ Mesh ä¸´æ—¶ç§»å‡º Group
                        // ç®€åŒ–ç‰ˆï¼šæˆ‘ä»¬è®© Group åœæ­¢æ—‹è½¬ï¼ŒæŠŠç›®æ ‡è®¾ä¸ºç›¸æœºå‰æ–¹
                        
                        // ç”±äºGroupåœ¨æ—‹è½¬ï¼Œè®¡ç®—ä¸–ç•Œåæ ‡ç³»ä¸‹çš„ç›¸æœºå‰æ–¹æœ‰ç‚¹å¤æ‚ã€‚
                        // ç®€å•åšæ³•ï¼šæˆ‘ä»¬æŠŠè¿™å¼ ç…§ç‰‡çš„ç›®æ ‡ä½ç½®è®¾ä¸º Group çš„é€†å˜æ¢ä½ç½®
                        
                        // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„é€»è¾‘ï¼šInspectçŠ¶æ€ä¸‹ï¼ŒGroup rotation å½’é›¶
                        target = new THREE.Vector3(0, 0, 30); // ç¦»ç›¸æœºè¿‘ä¸€ç‚¹
                        scaleTarget = 3.0;
                        obj.mesh.lookAt(camera.position);
                    } else {
                        // å…¶ä»–ç‰©ä½“æ•£å¼€å¹¶æ¨è¿œ
                        target = obj.cloudPos.clone().multiplyScalar(1.5);
                        scaleTarget = 0.1; // å˜å°
                    }
                }

                // æ’å€¼ç§»åŠ¨ (Lerp)
                obj.mesh.position.lerp(target, 0.05); // 0.05 å†³å®šäº†è¿‡æ¸¡é€Ÿåº¦
                
                // æ’å€¼ç¼©æ”¾
                const s = obj.mesh.scale.x + (scaleTarget - obj.mesh.scale.x) * 0.05;
                obj.mesh.scale.set(s, s, s);
            });
            
            // Inspect æ¨¡å¼ä¸‹ç‰¹æ®Šå¤„ç† Group æ—‹è½¬å½’é›¶
            if (currentState === STATE.INSPECT) {
                targetRotation = { x: 0, y: 0 };
            }

            composer.render();
        }

        animate();

        // --- MediaPipe Hands é›†æˆ ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const stateDOM = document.getElementById('current-state');
        const hintDOM = document.getElementById('gesture-hint');
        const loadingDOM = document.getElementById('loading');

        function onResults(results) {
            loadingDOM.style.display = 'none';

            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                hintDOM.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
                return;
            }

            const landmarks = results.multiHandLandmarks[0];
            
            // 1. æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
            // å…³é”®ç‚¹: 0(æ‰‹è…•), 4(æ‹‡æŒ‡å°–), 8(é£ŸæŒ‡å°–), 12(ä¸­æŒ‡å°–), 16(æ— åæŒ‡å°–), 20(å°æŒ‡å°–)
            
            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦» (å½’ä¸€åŒ–åçš„åæ ‡)
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20]; // ä¸åŒ…å«æ‹‡æŒ‡
            let avgDist = 0;
            tips.forEach(idx => {
                const tip = landmarks[idx];
                const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                avgDist += d;
            });
            avgDist /= 4;

            // è®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è·ç¦» (ç”¨äº pinch)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

            let detectedGesture = '';

            // é˜ˆå€¼éœ€è¦æ ¹æ®å®é™…ä½“éªŒå¾®è°ƒ
            if (pinchDist < 0.05) {
                detectedGesture = 'PINCH';
            } else if (avgDist < 0.25) { // æ‰‹æŒ‡èœ·ç¼©
                detectedGesture = 'FIST';
            } else if (avgDist > 0.4) { // æ‰‹æŒ‡å¼ å¼€
                detectedGesture = 'OPEN';
            } else {
                detectedGesture = 'UNKNOWN';
            }

            hintDOM.innerText = `æ£€æµ‹æ‰‹åŠ¿: ${detectedGesture}`;

            // 2. çŠ¶æ€åˆ‡æ¢é€»è¾‘
            if (detectedGesture === 'FIST') {
                if (currentState !== STATE.TREE) {
                    currentState = STATE.TREE;
                    updateUI('TREE', '#2F5A2F');
                }
            } else if (detectedGesture === 'OPEN') {
                if (currentState !== STATE.CLOUD) {
                    currentState = STATE.CLOUD;
                    updateUI('CLOUD', '#D4AF37');
                }
                
                // æ‰‹æŒç§»åŠ¨æ§åˆ¶æ—‹è½¬ (ä»…åœ¨ Open/Cloud çŠ¶æ€ä¸‹)
                // æ˜ å°„ x: [0, 1] -> [-PI, PI]
                // ç”»é¢æ˜¯é•œåƒçš„ï¼Œæ‰€ä»¥æ–¹å‘è¦è°ƒæ•´
                targetRotation.x = (0.5 - wrist.x) * 4; 
                targetRotation.y = (0.5 - wrist.y) * 2;

            } else if (detectedGesture === 'PINCH') {
                if (currentState !== STATE.INSPECT) {
                    // éšæœºé€‰å–ä¸€å¼ ç…§ç‰‡æˆ–è€…é€‰å–æœ€é è¿‘ä¸­å¿ƒçš„ç…§ç‰‡
                    // ç®€å•èµ·è§ï¼Œéšæœºé€‰ä¸€ä¸ª photo ç±»å‹çš„å¯¹è±¡
                    const photoObjects = objects.map((obj, i) => ({...obj, originalIndex: i})).filter(o => o.type === 'photo');
                    if(photoObjects.length > 0) {
                        const randomPhoto = photoObjects[Math.floor(Math.random() * photoObjects.length)];
                        activePhotoIndex = randomPhoto.originalIndex;
                        
                        currentState = STATE.INSPECT;
                        updateUI('INSPECT', '#B22222');
                    }
                }
            }
        }
        
        function updateUI(stateName, color) {
            stateDOM.innerText = `STATE: ${stateName}`;
            stateDOM.style.color = color;
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        cameraUtils.start();

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
